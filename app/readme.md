## 须知
#### Inject，Component，Module，Provides是dagger2中的最基础最核心的知识点。奠定了dagger2的整个依赖注入框架。
1. Inject主要是用来标注目标类的依赖和依赖的构造函数
2. Component它是一个桥梁，一端是目标类，另一端是目标类所依赖类的实例，它也是注入器（Injector）负责把目标类所依赖类的实例注入到目标类中，同时它也管理Module。
3. Module和Provides是为解决第三方类库而生的，Module是一个简单工厂模式，Module可以包含创建类实例的方法，这些方法用Provides来标注

##1.onlyInject
--
LocalSource
```java
package com.demo.lizejun.dagger2sample.chapter1;

import javax.inject.Inject;

public class LocalSource {

//	@Inject(注释掉的话只会生成DataRepository_MembersInjector)
	public LocalSource() {
	}
//    @Inject //（不能有两个注解）
//	public LocalSource(String name) {
//		mName = name;
//	}
	public String getData() {
		return "使用在构造函数上使用 @Inject 的方式，获取到了本地数据";
	}
}

```
 DaggerSourceComponent
```java
// Generated by dagger.internal.codegen.ComponentProcessor (https://google.github.io/dagger).
package com.demo.lizejun.dagger2sample.chapter1;

import dagger.MembersInjector;
//生成的实现类component会实现对应的component接口
public final class DaggerSourceComponent implements SourceComponent {
  private MembersInjector<DataRepository> dataRepositoryMembersInjector;

  private DaggerSourceComponent(Builder builder) {
    assert builder != null;
    initialize(builder);
  }

  public static Builder builder() {
    return new Builder();
  }

  public static SourceComponent create() {
    return new Builder().build();
  }

  @SuppressWarnings("unchecked")
  private void initialize(final Builder builder) {

    this.dataRepositoryMembersInjector =
        DataRepository_MembersInjector.create(LocalSource_Factory.create());
  }

  @Override
  public void inject(DataRepository dataRepository) {
    dataRepositoryMembersInjector.injectMembers(dataRepository);
  }

  public static final class Builder {
    private Builder() {}

    public SourceComponent build() {
      return new DaggerSourceComponent(this);
    }
  }
}

```
DataRepository_MembersInjector

```java
// Generated by dagger.internal.codegen.ComponentProcessor (https://google.github.io/dagger).
package com.demo.lizejun.dagger2sample.chapter1;

import dagger.MembersInjector;
import javax.inject.Provider;

public final class DataRepository_MembersInjector implements MembersInjector<DataRepository> {
  private final Provider<LocalSource> mLocalSourceProvider;

  public DataRepository_MembersInjector(Provider<LocalSource> mLocalSourceProvider) {
    assert mLocalSourceProvider != null;
    this.mLocalSourceProvider = mLocalSourceProvider;
  }

  public static MembersInjector<DataRepository> create(Provider<LocalSource> mLocalSourceProvider) {
    return new DataRepository_MembersInjector(mLocalSourceProvider);
  }

  @Override
  public void injectMembers(DataRepository instance) {
    if (instance == null) {
      throw new NullPointerException("Cannot inject members into a null reference");
    }
    instance.mLocalSource = mLocalSourceProvider.get();
  }

  public static void injectMLocalSource(
      DataRepository instance, Provider<LocalSource> mLocalSourceProvider) {
    instance.mLocalSource = mLocalSourceProvider.get();
  }
}

```
 LocalSource_Factory

```java
// Generated by dagger.internal.codegen.ComponentProcessor (https://google.github.io/dagger).
package com.demo.lizejun.dagger2sample.chapter1;

import dagger.internal.Factory;

public final class LocalSource_Factory implements Factory<LocalSource> {
  private static final LocalSource_Factory INSTANCE = new LocalSource_Factory();

  @Override
  public LocalSource get() {
    return new LocalSource();
  }

  public static Factory<LocalSource> create() {
    return INSTANCE;
  }
}

```
##2.onlyInject+参数
--
DaggerSourceComponent
```java
// Generated by dagger.internal.codegen.ComponentProcessor (https://google.github.io/dagger).
package com.demo.lizejun.dagger2sample.chapter1;

import dagger.MembersInjector;
import dagger.internal.Preconditions;
import javax.inject.Provider;

public final class DaggerSourceComponent implements SourceComponent {
    //一个参数也会有一个provider
  private Provider<String> providelocalStringProvider;
    //这个onlyInject也有，只是没有作为成员变量
  private Provider<LocalSource> localSourceProvider;

  private MembersInjector<DataRepository> dataRepositoryMembersInjector;

  private DaggerSourceComponent(Builder builder) {
    assert builder != null;
    initialize(builder);
  }

  public static Builder builder() {
    return new Builder();
  }

  public static SourceComponent create() {
    return new Builder().build();
  }

  @SuppressWarnings("unchecked")
  private void initialize(final Builder builder) {
  	//依赖于String参数，那么就需要先实例化这个参数。
    this.providelocalStringProvider =
        StringModule_ProvidelocalStringFactory.create(builder.stringModule);

    this.localSourceProvider = LocalSource_Factory.create(providelocalStringProvider);

    this.dataRepositoryMembersInjector = DataRepository_MembersInjector.create(localSourceProvider);
  }

  @Override
  public void inject(DataRepository dataRepository) {
    dataRepositoryMembersInjector.injectMembers(dataRepository);
  }

  public static final class Builder {
    private StringModule stringModule;

    private Builder() {}

    public SourceComponent build() {
      if (stringModule == null) {
        this.stringModule = new StringModule();
      }
      return new DaggerSourceComponent(this);
    }

    public Builder stringModule(StringModule stringModule) {
      this.stringModule = Preconditions.checkNotNull(stringModule);
      return this;
    }
  }
}

```
MembersInjector
```java
// Generated by dagger.internal.codegen.ComponentProcessor (https://google.github.io/dagger).
package com.demo.lizejun.dagger2sample.chapter1;

import dagger.MembersInjector;
import javax.inject.Provider;

public final class DataRepository_MembersInjector implements MembersInjector<DataRepository> {
  private final Provider<LocalSource> mLocalSourceProvider;

  public DataRepository_MembersInjector(Provider<LocalSource> mLocalSourceProvider) {
    assert mLocalSourceProvider != null;
    this.mLocalSourceProvider = mLocalSourceProvider;
  }

  public static MembersInjector<DataRepository> create(Provider<LocalSource> mLocalSourceProvider) {
    return new DataRepository_MembersInjector(mLocalSourceProvider);
  }

  @Override
  public void injectMembers(DataRepository instance) {
    if (instance == null) {
      throw new NullPointerException("Cannot inject members into a null reference");
    }
    instance.mLocalSource = mLocalSourceProvider.get();
  }

  public static void injectMLocalSource(
      DataRepository instance, Provider<LocalSource> mLocalSourceProvider) {
    instance.mLocalSource = mLocalSourceProvider.get();
  }
}

```
LocalSource_Factory
```java
// Generated by dagger.internal.codegen.ComponentProcessor (https://google.github.io/dagger).
package com.demo.lizejun.dagger2sample.chapter1;

import dagger.internal.Factory;
import javax.inject.Provider;

public final class LocalSource_Factory implements Factory<LocalSource> {
  private final Provider<String> nameProvider;

  public LocalSource_Factory(Provider<String> nameProvider) {
    assert nameProvider != null;
    this.nameProvider = nameProvider;
  }

  @Override
  public LocalSource get() {
    return new LocalSource(nameProvider.get());
  }

  public static Factory<LocalSource> create(Provider<String> nameProvider) {
    return new LocalSource_Factory(nameProvider);
  }
}

```
##3.onlyModule
---
DaggerSourceComponent
```java
// Generated by dagger.internal.codegen.ComponentProcessor (https://google.github.io/dagger).
package com.demo.lizejun.dagger2sample.chapter1;

import dagger.MembersInjector;
import dagger.internal.Preconditions;
import javax.inject.Provider;

public final class DaggerSourceComponent implements SourceComponent {
    //只有一个provider
  private Provider<RemoteSource> provideRemoteSourcetestProvider;

  private MembersInjector<DataRepository> dataRepositoryMembersInjector;

  private DaggerSourceComponent(Builder builder) {
    assert builder != null;
    initialize(builder);
  }

  public static Builder builder() {
    return new Builder();
  }

  public static SourceComponent create() {
    return new Builder().build();
  }

  @SuppressWarnings("unchecked")
  private void initialize(final Builder builder) {
    //module会作为创建factory的参数
    this.provideRemoteSourcetestProvider =
        RemoteSourceModule_ProvideRemoteSourcetestFactory.create(builder.remoteSourceModule);
 //actory会作为创建MembersInjector的参数
    this.dataRepositoryMembersInjector =
        DataRepository_MembersInjector.create(provideRemoteSourcetestProvider);
  }

  @Override
  public void inject(DataRepository dataRepository) {
    dataRepositoryMembersInjector.injectMembers(dataRepository);
  }

  public static final class Builder {
    //依赖的module会在DaggerSourceComponent的内部类Builder作为成员变量
    private RemoteSourceModule remoteSourceModule;

    private Builder() {}

    public SourceComponent build() {
      if (remoteSourceModule == null) {
        this.remoteSourceModule = new RemoteSourceModule();
      }
      return new DaggerSourceComponent(this);
    }
    //持有module的类名变成方法名
    public Builder remoteSourceModule(RemoteSourceModule remoteSourceModule) {
      this.remoteSourceModule = Preconditions.checkNotNull(remoteSourceModule);
      return this;
    }
  }
}

```
DataRepository_MembersInjector
```java
// Generated by dagger.internal.codegen.ComponentProcessor (https://google.github.io/dagger).
package com.demo.lizejun.dagger2sample.chapter1;

import dagger.MembersInjector;
import javax.inject.Provider;

public final class DataRepository_MembersInjector implements MembersInjector<DataRepository> {
  private final Provider<RemoteSource> mRemoteSourceProvider;

  public DataRepository_MembersInjector(Provider<RemoteSource> mRemoteSourceProvider) {
    assert mRemoteSourceProvider != null;
    this.mRemoteSourceProvider = mRemoteSourceProvider;
  }

  public static MembersInjector<DataRepository> create(
      Provider<RemoteSource> mRemoteSourceProvider) {
    return new DataRepository_MembersInjector(mRemoteSourceProvider);
  }

  @Override
  public void injectMembers(DataRepository instance) {
    if (instance == null) {
      throw new NullPointerException("Cannot inject members into a null reference");
    }
    instance.mRemoteSource = mRemoteSourceProvider.get();
  }

  public static void injectMRemoteSource(
      DataRepository instance, Provider<RemoteSource> mRemoteSourceProvider) {
    instance.mRemoteSource = mRemoteSourceProvider.get();
  }
}

```
RemoteSourceModule_ProvideRemoteSourcetestFactory
```java
// Generated by dagger.internal.codegen.ComponentProcessor (https://google.github.io/dagger).
package com.demo.lizejun.dagger2sample.chapter1;

import dagger.internal.Factory;
import dagger.internal.Preconditions;
//RemoteSourceModule_ProvideRemoteSourcetestFactory由moudle名和方法决定
public final class RemoteSourceModule_ProvideRemoteSourcetestFactory
    implements Factory<RemoteSource> {
  private final RemoteSourceModule module;

  public RemoteSourceModule_ProvideRemoteSourcetestFactory(RemoteSourceModule module) {
    assert module != null;
    this.module = module;
  }

  @Override
  public RemoteSource get() {
    return Preconditions.checkNotNull(
        module.provideRemoteSourcetest(),
        "Cannot return null from a non-@Nullable @Provides method");
  }

  public static Factory<RemoteSource> create(RemoteSourceModule module) {
    return new RemoteSourceModule_ProvideRemoteSourcetestFactory(module);
  }
}

```
##4.依赖注入迷失
---
```java
package com.demo.lizejun.dagger2sample.chapter2;
import dagger.Module;
import dagger.Provides;
@Module
public class SourceModule {
    //会出现依赖注入迷失
    //这是因为Dagger2在寻找mLocalSource的创建方法时，它会去Component关联的Module中
    // （也就是SourceModule）寻找返回类型为Source的方法，但是在SourceModule中，provideLocalSource / providerRemoteSource这两个方法返回的类型都为Source，
    // 导致无法确定使用哪个方法来创建mLocalSource。
    //一般来说，使用@Qulifier是比较标准的方式

    @Provides
//    @Named("Local")
    public Source provideLocalSource() {
        return new LocalSource();
    }

    @Provides
//    @Named("Remote")
    public Source providerRemoteSource() {
        return new RemoteSource();
    }
}

```
##5.依赖方式
--
DaggerDependencyComponent
```java
// Generated by dagger.internal.codegen.ComponentProcessor (https://google.github.io/dagger).
package com.demo.lizejun.dagger2sample.chapter3;

import dagger.internal.Preconditions;
import javax.inject.Provider;

public final class DaggerDependencyComponent implements DependencyComponent {
  private Provider<DependencySource> provideDependencySourceProvider;

  private DaggerDependencyComponent(Builder builder) {
    assert builder != null;
    initialize(builder);
  }

  public static Builder builder() {
    return new Builder();
  }

  public static DependencyComponent create() {
    return new Builder().build();
  }

  @SuppressWarnings("unchecked")
  private void initialize(final Builder builder) {
    //这里只创建了provider，因为该类不提供注入的方法
    this.provideDependencySourceProvider =
        DependencyModule_ProvideDependencySourceFactory.create(builder.dependencyModule);
  }
  //inject 变成了getDependencySource
  @Override
  public DependencySource getDependencySource() {
    return provideDependencySourceProvider.get();
  }

  public static final class Builder {
      //依赖的module会在DaggerSourceComponent的内部类Builder作为成员变量
    private DependencyModule dependencyModule;

    private Builder() {}
    //采用的是builder模式，build方法会创建外部类对象
    public DependencyComponent build() {
      if (dependencyModule == null) {
        this.dependencyModule = new DependencyModule();
      }
      return new DaggerDependencyComponent(this);
    }
    //持有module的类名变成方法名
    public Builder dependencyModule(DependencyModule dependencyModule) {
      this.dependencyModule = Preconditions.checkNotNull(dependencyModule);
      return this;
    }
  }
}

```
DaggerSourceComponent
```java
// Generated by dagger.internal.codegen.ComponentProcessor (https://google.github.io/dagger).
package com.demo.lizejun.dagger2sample.chapter3;

import dagger.MembersInjector;
import dagger.internal.Preconditions;
import javax.inject.Provider;

public final class DaggerSourceComponent implements SourceComponent {
  private Provider<DependencySource> getDependencySourceProvider;

  private MembersInjector<DataRepository> dataRepositoryMembersInjector;

  private DaggerSourceComponent(Builder builder) {
    assert builder != null;
    initialize(builder);
  }

  public static Builder builder() {
    return new Builder();
  }

  @SuppressWarnings("unchecked")
  private void initialize(final Builder builder) {
    //之前创建的是factory，把moudle传进去
    //现在创建的是provider,把component传进去
    this.getDependencySourceProvider =
        new com_demo_lizejun_dagger2sample_chapter3_DependencyComponent_getDependencySource(
            builder.dependencyComponent);

    this.dataRepositoryMembersInjector =
        DataRepository_MembersInjector.create(getDependencySourceProvider);
  }
  //通过dataRepositoryMembersInjector注入，dataRepositoryMembersInjector里面实际用的是provider去拿
  //一般的是provider通过get方法直接去拿或者通过moudle，这里的话是通过依赖的component
  @Override
  public void inject(DataRepository dataRepository) {
    dataRepositoryMembersInjector.injectMembers(dataRepository);
  }

  public static final class Builder {
    //因为component依赖的是另一个component,所以这个component作为成员变量
    private DependencyComponent dependencyComponent;

    private Builder() {}

    public SourceComponent build() {
      if (dependencyComponent == null) {
        throw new IllegalStateException(
            DependencyComponent.class.getCanonicalName() + " must be set");
      }
      return new DaggerSourceComponent(this);
    }

    public Builder dependencyComponent(DependencyComponent dependencyComponent) {
      this.dependencyComponent = Preconditions.checkNotNull(dependencyComponent);
      return this;
    }
  }

  private static
  class com_demo_lizejun_dagger2sample_chapter3_DependencyComponent_getDependencySource
      implements Provider<DependencySource> {
    private final DependencyComponent dependencyComponent;

    com_demo_lizejun_dagger2sample_chapter3_DependencyComponent_getDependencySource(
        DependencyComponent dependencyComponent) {
      this.dependencyComponent = dependencyComponent;
    }

    @Override
    public DependencySource get() {
      return Preconditions.checkNotNull(
          dependencyComponent.getDependencySource(),
          "Cannot return null from a non-@Nullable component method");
    }
  }
}

```
##5.继承方式
--
DaggerSourceComponent
```java
// Generated by dagger.internal.codegen.ComponentProcessor (https://google.github.io/dagger).
package com.demo.lizejun.dagger2sample.chapter3;

import dagger.MembersInjector;
import dagger.internal.Preconditions;
import javax.inject.Provider;

public final class DaggerSourceComponent implements SourceComponent {
  private Provider<DependencySource> getDependencySourceProvider;

  private MembersInjector<DataRepository> dataRepositoryMembersInjector;

  private Provider<LocalSource> provideLocalSourceProvider;

  private DaggerSourceComponent(Builder builder) {
    assert builder != null;
    initialize(builder);
  }

  public static Builder builder() {
    return new Builder();
  }

  @SuppressWarnings("unchecked")
  private void initialize(final Builder builder) {

    this.getDependencySourceProvider =
        new com_demo_lizejun_dagger2sample_chapter3_DependencyComponent_getDependencySource(
            builder.dependencyComponent);

    this.dataRepositoryMembersInjector =
        DataRepository_MembersInjector.create(getDependencySourceProvider);
   
    this.provideLocalSourceProvider =
        SourceModule_ProvideLocalSourceFactory.create(builder.sourceModule);
  }

  @Override
  public void inject(DataRepository dataRepository) {
    dataRepositoryMembersInjector.injectMembers(dataRepository);
  }

  //实现接口实现的方法
  @Override
  public SubSourceComponent getSubSourceComponent() {
    return new SubSourceComponentImpl();
  }

  public static final class Builder {
    private SourceModule sourceModule;

    private DependencyComponent dependencyComponent;

    private Builder() {}

    public SourceComponent build() {
      if (sourceModule == null) {
        this.sourceModule = new SourceModule();
      }
      if (dependencyComponent == null) {
        throw new IllegalStateException(
            DependencyComponent.class.getCanonicalName() + " must be set");
      }
      return new DaggerSourceComponent(this);
    }

    public Builder sourceModule(SourceModule sourceModule) {
      this.sourceModule = Preconditions.checkNotNull(sourceModule);
      return this;
    }

    public Builder dependencyComponent(DependencyComponent dependencyComponent) {
      this.dependencyComponent = Preconditions.checkNotNull(dependencyComponent);
      return this;
    }
  }

  private static
  class com_demo_lizejun_dagger2sample_chapter3_DependencyComponent_getDependencySource
      implements Provider<DependencySource> {
    private final DependencyComponent dependencyComponent;

    com_demo_lizejun_dagger2sample_chapter3_DependencyComponent_getDependencySource(
        DependencyComponent dependencyComponent) {
      this.dependencyComponent = dependencyComponent;
    }

    @Override
    public DependencySource get() {
      return Preconditions.checkNotNull(
          dependencyComponent.getDependencySource(),
          "Cannot return null from a non-@Nullable component method");
    }
  }
    //@subComponent注解生成的实现类component在其父component的实现类生成
  private final class SubSourceComponentImpl implements SubSourceComponent {
    private MembersInjector<SubRepository> subRepositoryMembersInjector;

    private SubSourceComponentImpl() {
      initialize();
    }

    @SuppressWarnings("unchecked")
    private void initialize() {
    //因为该类有inject方法，所以会生成SubRepository_MembersInjector，其provider是其父类注解中的moudle来创建出来的
      this.subRepositoryMembersInjector =
          SubRepository_MembersInjector.create(
              DaggerSourceComponent.this.provideLocalSourceProvider);
    }
    @Override
    public void inject(SubRepository subRepository) {
      subRepositoryMembersInjector.injectMembers(subRepository);
    }
  }
}

```

